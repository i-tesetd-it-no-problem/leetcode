#include <stdio.h>
#include <stdbool.h>
#include <string.h>

/*
给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s 的，而不是部分字符串。

 
示例 1：

输入：s = "aa", p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。
示例 2:

输入：s = "aa", p = "a*"
输出：true
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
示例 3：

输入：s = "ab", p = ".*"
输出：true
解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
*/

/*
原理

初始化：
dp[0][0] = true：空字符串和空模式是匹配的。
如果模式 p 的前面部分是 *，则 dp[0][j] 需要根据 * 前的字符匹配零次，初始化为 dp[0][j-2]（即模式中出现零次字符时的匹配情况）

如果 p[j-1] 是 *，则有两种情况：
dp[i][j] = dp[i][j-2]：表示 * 前的字符出现零次，即跳过 * 和它前面的字符。
dp[i][j] = dp[i-1][j]：表示 * 前的字符出现一次或多次，这时候当前字符 s[i-1] 必须和 p[j-2] 匹配（即 s[i-1] == p[j-2] 或 p[j-2] == '.'）。
*/

bool isMatch(char *s, char *p)
{
	int m = strlen(s), n = strlen(p);
	bool dp[m + 1][n + 1];
	memset(dp, false, sizeof(dp));

	// 空字符串和空模式是匹配的
	dp[0][0] = true;

	// 处理模式串 p 开头的 '*' 匹配空字符串的情况
	// 当模式中有多个连续的 *，我们需要检查 * 是否能匹配零个字符
	for (int j = 1; j <= n; j++) {
		// 如果 p[j-1] 是 *，我们需要看它前面的字符是否能够匹配空字符串。
		// 如果 p[j-2] 能够匹配空字符串，那么 dp[0][j] 应该为 true。
		dp[0][j] = (p[j - 1] == '*' && dp[0][j - 2]);
	}

	// 遍历字符串 s
	for (int i = 1; i <= m; i++) {
		// 遍历模式 p
		for (int j = 1; j <= n; j++) {
			if (p[j - 1] == s[i - 1] || p[j - 1] == '.') {
				// 如果当前字符相同，或者模式字符是 .（可以匹配任意字符），
				// 那么当前 dp[i][j] 可以由 dp[i-1][j-1] 推导出来。
				// 即：匹配当前位置的字符后，继续匹配前面部分。
				dp[i][j] = dp[i - 1][j - 1];
			} else if (p[j - 1] == '*') {
				// 如果模式中的当前字符是 *，我们有两种情况：

				// 1. * 表示前面的字符出现零次：可以跳过 * 和它前面的字符，检查 dp[i][j-2]。
				//    例如，模式 "a*" 可以匹配空字符串。
				// 2. * 表示前面的字符出现一次或多次：我们检查 dp[i-1][j]，即字符串中的字符与模式中的前一个字符匹配。
				//    同时，当前字符 s[i-1] 和模式中的 p[j-2] 必须匹配，或者 p[j-2] 是 .（可以匹配任意字符）。
				dp[i][j] = dp[i][j - 2] || (dp[i - 1][j] && (s[i - 1] == p[j - 2] || p[j - 2] == '.'));
			} else {
				// 如果当前模式字符既不是 . 也不是 *，并且与字符串当前字符不匹配，
				// 那么 dp[i][j] 一定为 false。
				dp[i][j] = false;
			}
		}
	}

	return dp[m][n];
}

int main()
{
	char *s = "aa";
	char *p = "a*";
	printf("%d\n", isMatch(s, p)); // 输出 1（匹配成功）
	return 0;
}